[
    {
        "id": "0f34f41d8ec5ac00",
        "type": "mqtt in",
        "z": "d4e33c145f0fb0dd",
        "name": "MQTT",
        "topic": "10021296/T202411140906020fkk/gate/dfrobot/devices/lora/+/up",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "da93bc8d835d541e",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 490,
        "y": 540,
        "wires": [
            [
                "2573346123eaec07",
                "c598fb4dee62c475",
                "9183fe24361739b0"
            ]
        ]
    },
    {
        "id": "2573346123eaec07",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "msg.payload",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 730,
        "y": 580,
        "wires": []
    },
    {
        "id": "10751038bc0728b6",
        "type": "comment",
        "z": "d4e33c145f0fb0dd",
        "name": "MQTT from CRa LoRaWAN",
        "info": "",
        "x": 440,
        "y": 500,
        "wires": []
    },
    {
        "id": "57e3cdb6bee5536b",
        "type": "inject",
        "z": "d4e33c145f0fb0dd",
        "name": "JSON test data",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"cmd\":\"gw\",\"ts\":1736855162722,\"data\":\"5502fc88b400db8fd1\",\"fcnt\":0,\"port\":1,\"freq\":868500000,\"dr\":\"SF7 BW125 4/5\",\"ack\":false,\"gws\":[{\"rssi\":-84,\"snr\":10.5,\"gweui\":\"647FDAFFFF007577\",\"ant\":0},{\"rssi\":-94,\"snr\":6.25,\"gweui\":\"647FDAFFFF0069CB\",\"ant\":0},{\"rssi\":-120,\"snr\":-10,\"gweui\":\"647FDAFFFF00AD6F\",\"ant\":0},{\"rssi\":-110,\"snr\":-3,\"gweui\":\"647FDAFFFF006A47\",\"ant\":0}],\"bat\":255,\"EUI\":\"70B3D57ED800386A\"}",
        "payloadType": "json",
        "x": 480,
        "y": 620,
        "wires": [
            [
                "c598fb4dee62c475"
            ]
        ]
    },
    {
        "id": "301d811202473308",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "Debug influxDB out",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1130,
        "y": 740,
        "wires": []
    },
    {
        "id": "8a0dc761b2fd6cbe",
        "type": "influxdb batch",
        "z": "d4e33c145f0fb0dd",
        "influxdb": "9740419a576efa0b",
        "precision": "",
        "retentionPolicy": "",
        "name": "Google VM influxDB",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "pavel.travnicek.89@gmail.com",
        "bucket": "container",
        "x": 1140,
        "y": 700,
        "wires": []
    },
    {
        "id": "d57c675cedad0f02",
        "type": "udp in",
        "z": "d4e33c145f0fb0dd",
        "name": "UDP in message",
        "iface": "",
        "port": "8094",
        "ipv": "udp4",
        "multicast": "false",
        "group": "",
        "datatype": "buffer",
        "x": 500,
        "y": 1260,
        "wires": [
            [
                "865555cd5a00c3e4",
                "8219c6e538162b47"
            ]
        ]
    },
    {
        "id": "865555cd5a00c3e4",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "UDP debug",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 730,
        "y": 1320,
        "wires": []
    },
    {
        "id": "f893f88c539847e3",
        "type": "comment",
        "z": "d4e33c145f0fb0dd",
        "name": "UDP envData from Nb-IoT module",
        "info": "",
        "x": 440,
        "y": 1220,
        "wires": []
    },
    {
        "id": "2b953c6e708524f2",
        "type": "inject",
        "z": "d4e33c145f0fb0dd",
        "name": "Write Image Now",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 520,
        "y": 1980,
        "wires": [
            [
                "0c9ecfba4732f7ad"
            ]
        ]
    },
    {
        "id": "0c9ecfba4732f7ad",
        "type": "function",
        "z": "d4e33c145f0fb0dd",
        "name": "Prepare File Out",
        "func": "// get the fully accumulated buffer\nlet finalImage = flow.get('accumulatedBuffer') || Buffer.alloc(0);\n\n// if zero length, probably no image received yet\nif(finalImage.length === 0){\n    node.warn('No data available');\n    return null;\n}\n\nmsg.payload = finalImage;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 1980,
        "wires": [
            [
                "39a907690f09d919"
            ]
        ]
    },
    {
        "id": "39a907690f09d919",
        "type": "file",
        "z": "d4e33c145f0fb0dd",
        "name": "Write JPEG",
        "filename": "/home/images/my_image.jpg",
        "filenameType": "str",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": "true",
        "encoding": "none",
        "x": 910,
        "y": 1980,
        "wires": [
            [
                "5859f017fa7d5df4"
            ]
        ]
    },
    {
        "id": "resetButton",
        "type": "inject",
        "z": "d4e33c145f0fb0dd",
        "name": "Reset Buffer",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "",
        "topic": "",
        "x": 910,
        "y": 2060,
        "wires": [
            [
                "resetFunc"
            ]
        ]
    },
    {
        "id": "resetFunc",
        "type": "function",
        "z": "d4e33c145f0fb0dd",
        "name": "Clear Flow Buffer",
        "func": "flow.set('accumulatedBuffer', Buffer.alloc(0));\nnode.warn('Buffer has been reset');\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 2060,
        "wires": [
            []
        ]
    },
    {
        "id": "2aef65997aefbe8c",
        "type": "complete",
        "z": "d4e33c145f0fb0dd",
        "name": "",
        "scope": [
            "fileOutNode"
        ],
        "uncaught": false,
        "x": 910,
        "y": 2020,
        "wires": [
            [
                "resetFunc",
                "f67d391efccb60ba"
            ]
        ]
    },
    {
        "id": "f67d391efccb60ba",
        "type": "file in",
        "z": "d4e33c145f0fb0dd",
        "name": "Read My Image",
        "filename": "/home/images/my_image.jpg",
        "filenameType": "str",
        "format": "",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 1100,
        "y": 2120,
        "wires": [
            [
                "f16513b17251883b"
            ]
        ]
    },
    {
        "id": "f16513b17251883b",
        "type": "image viewer",
        "z": "d4e33c145f0fb0dd",
        "name": "Preview Image",
        "width": "420",
        "data": "payload",
        "dataType": "msg",
        "active": true,
        "x": 1300,
        "y": 2120,
        "wires": [
            []
        ]
    },
    {
        "id": "096204517f694865",
        "type": "inject",
        "z": "d4e33c145f0fb0dd",
        "name": "Read Image Now",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 900,
        "y": 2120,
        "wires": [
            [
                "f67d391efccb60ba"
            ]
        ]
    },
    {
        "id": "3662fa3ece482485",
        "type": "http request",
        "z": "d4e33c145f0fb0dd",
        "name": "image POST",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://rm.fsv.cvut.cz/upload_container_image",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "other",
                "keyValue": "Content-Type",
                "valueType": "other",
                "valueValue": "image/jpeg"
            }
        ],
        "x": 1190,
        "y": 1940,
        "wires": [
            [
                "843d6b49a0666b25"
            ]
        ]
    },
    {
        "id": "843d6b49a0666b25",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1380,
        "y": 1940,
        "wires": []
    },
    {
        "id": "5859f017fa7d5df4",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "debug 3",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1380,
        "y": 2000,
        "wires": []
    },
    {
        "id": "7fdc8cf9ba807e92",
        "type": "function",
        "z": "d4e33c145f0fb0dd",
        "name": "Accumulate Binary",
        "func": "// Merge with prior buffer\nlet oldBuffer = flow.get('accumulatedBuffer') || Buffer.alloc(0);\nlet newBuffer = Buffer.concat([oldBuffer, msg.payload]);\nflow.set('accumulatedBuffer', newBuffer);\n\n// For debug, show sizes\nnode.warn(`Received chunk: ${msg.payload.length} bytes, total: ${newBuffer.length}`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1900,
        "wires": [
            []
        ]
    },
    {
        "id": "899e97ce88547558",
        "type": "complete",
        "z": "d4e33c145f0fb0dd",
        "name": "",
        "scope": [
            "7fdc8cf9ba807e92"
        ],
        "uncaught": false,
        "x": 530,
        "y": 1940,
        "wires": [
            [
                "0c9ecfba4732f7ad"
            ]
        ]
    },
    {
        "id": "916068870f124f97",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "debug 4",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 720,
        "y": 1100,
        "wires": []
    },
    {
        "id": "022d251b920e6e05",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "debug 5",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 1140,
        "wires": []
    },
    {
        "id": "73b91a9ca531534e",
        "type": "file",
        "z": "d4e33c145f0fb0dd",
        "name": "Write /home/images/my_image.jpg",
        "filename": "/home/images/my_image.jpg",
        "filenameType": "str",
        "appendNewline": false,
        "createDir": false,
        "overwriteFile": "true",
        "encoding": "binary",
        "x": 1180,
        "y": 1060,
        "wires": [
            [
                "56ebbfc93a3874b0"
            ]
        ]
    },
    {
        "id": "56ebbfc93a3874b0",
        "type": "http request",
        "z": "d4e33c145f0fb0dd",
        "name": "image POST",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://rm.fsv.cvut.cz/upload_container_image",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "other",
                "keyValue": "Content-Type",
                "valueType": "other",
                "valueValue": "image/jpeg"
            }
        ],
        "x": 1450,
        "y": 1120,
        "wires": [
            [
                "a4490d9f47094a12",
                "a20d9adb53729f1a"
            ]
        ]
    },
    {
        "id": "e7240357d8764f2b",
        "type": "tcp in",
        "z": "d4e33c145f0fb0dd",
        "name": "TCP Server",
        "server": "server",
        "host": "",
        "port": "8009",
        "datamode": "stream",
        "datatype": "buffer",
        "newline": "",
        "topic": "",
        "trim": false,
        "tls": "",
        "x": 490,
        "y": 1060,
        "wires": [
            [
                "916068870f124f97",
                "3a914eda261a3ec8"
            ]
        ]
    },
    {
        "id": "3a914eda261a3ec8",
        "type": "function",
        "z": "d4e33c145f0fb0dd",
        "name": "Accumulate & Check last 4 = 0xFF",
        "func": "// Retrieve existing buffer and started flag from flow context\nlet accumulated = flow.get('accumulatedBuffer') || Buffer.alloc(0);\nlet started = flow.get('photoTransferStarted') || false;\nlet lastReceiveTime = flow.get('lastReceiveTime') || 0;\n\n// Constants\nconst TIMEOUT_MS = 20000; // 20 seconds timeout\n\n// Ensure incoming is a Buffer first\nlet incoming = msg.payload;\nif (!Buffer.isBuffer(incoming)) {\n    incoming = Buffer.from(incoming);\n}\n\n// Check for timeout if we have started receiving data\nconst currentTime = Date.now();\nif (started && accumulated.length > 0 && (currentTime - lastReceiveTime > TIMEOUT_MS)) {\n    node.warn('Timeout: No data received for ' + TIMEOUT_MS / 1000 + ' seconds. Resetting buffer.');\n    accumulated = Buffer.alloc(0);\n    started = false;\n    flow.set('accumulatedBuffer', accumulated);\n    flow.set('photoTransferStarted', false);\n    flow.set('lastReceiveTime', 0);\n\n    // Check if current chunk has start marker\n    for (let i = 0; i <= incoming.length - 4; i++) {\n        if (incoming[i] === 0x00 &&\n            incoming[i + 1] === 0x00 &&\n            incoming[i + 2] === 0x00 &&\n            incoming[i + 3] === 0x00) {\n\n            // Found marker in current chunk after timeout\n            started = true;\n            flow.set('photoTransferStarted', true);\n            // Skip the marker (i + 4)\n            incoming = incoming.slice(i + 4);\n            node.warn('Found start marker in new chunk after timeout');\n            break;\n        }\n    }\n    if (!started) {\n        return null;\n    }\n}\n\n// Update last receive time\nflow.set('lastReceiveTime', Date.now());\n\n// If we haven't started yet, look for the beginning marker\nif (!started) {\n    // Check if this chunk contains the beginning marker\n    for (let i = 0; i <= incoming.length - 4; i++) {\n        if (incoming[i] === 0x00 &&\n            incoming[i + 1] === 0x00 &&\n            incoming[i + 2] === 0x00 &&\n            incoming[i + 3] === 0x00) {\n\n            started = true;\n            flow.set('photoTransferStarted', true);\n            // Skip the marker (i + 4)\n            incoming = incoming.slice(i + 4);\n            node.warn('Found beginning marker, starting accumulation');\n            break;\n        }\n    }\n\n    if (!started) {\n        //node.warn('Waiting for start marker...');\n        return null;\n    }\n}\n\n// Concatenate\naccumulated = Buffer.concat([accumulated, incoming]);\nflow.set('accumulatedBuffer', accumulated);\n\n// Debug sizes\n//node.warn(`Received chunk: ${incoming.length} bytes, total so far: ${accumulated.length}`);\n\n// Check for end marker (0xFF 0xFF 0xFF 0xFF)\nif (accumulated.length >= 4) {\n    const last4 = accumulated.slice(-4);\n\n    if (last4[0] === 0xFF && last4[1] === 0xFF &&\n        last4[2] === 0xFF && last4[3] === 0xFF) {\n\n        node.warn('Found end marker; emitting photo data');\n\n        // Remove the end marker from the final output\n        msg.payload = accumulated.slice(0, -4);\n\n        // Set headers for JPEG\n        msg.headers = {\n            'Content-Type': 'image/jpeg'\n        };\n\n        // Reset all accumulation state\n        flow.set('accumulatedBuffer', Buffer.alloc(0));\n        flow.set('photoTransferStarted', false);\n        flow.set('lastReceiveTime', 0);\n\n        return msg;\n    }\n}\n\n// Not complete yet, keep accumulating\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 1060,
        "wires": [
            [
                "022d251b920e6e05",
                "73b91a9ca531534e"
            ]
        ]
    },
    {
        "id": "a4490d9f47094a12",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "debug 6",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1640,
        "y": 1160,
        "wires": []
    },
    {
        "id": "c598fb4dee62c475",
        "type": "function",
        "z": "d4e33c145f0fb0dd",
        "name": "Return to rm.fsv.cvut.cz",
        "func": "// 1) Parse incoming JSON\nlet incoming = msg.payload;\n\nlet dataHex = incoming.data;\nlet bytes = Buffer.from(dataHex, \"hex\");\n\n// Safety check: ensure we have at least 11 bytes\nif (bytes.length < 11) {\n    node.warn(\"Not enough data bytes to decode (need 11).\");\n    return null;\n}\n\n// Battery (first byte)\nlet battery = bytes[0]; // e.g. 0x53 -> 83 decimal\n\n// GPS fix time in seconds (second byte)\nlet gpsFixTime = bytes[1];\n\n// Wake-up reason (third byte)\nlet wakeUpReason = bytes[2];\n\n// Latitude (signed 32-bit, big-endian at bytes[3..6])\nlet latInt = bytes.readInt32BE(3);\n// Longitude (signed 32-bit, big-endian at bytes[7..10])\nlet lonInt = bytes.readInt32BE(7);\n\n// Convert microdegrees to float degrees\nlet latitude = latInt / 1_000_000;\nlet longitude = lonInt / 1_000_000;\n\n// 3) Construct final POST body\n// Feel free to rename fields or adjust them as needed\nlet postBody = {\n    temperature: 0,\n    humidity: 0,\n    distance: 0,\n    latitude: latitude,\n    longitude: longitude,\n    container_id: 4,\n    image_status: 1,\n    battery_status: battery,\n    gps_fix_time: gpsFixTime,\n    wake_up_reason: wakeUpReason\n};\n\n// Assign to msg.payload for the next node (e.g., an HTTP Request node)\nmsg.payload = postBody;\n\n// Return message\nreturn msg;\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 840,
        "wires": [
            [
                "95c4b58937241783",
                "9b804076e0b2fcc3"
            ],
            []
        ]
    },
    {
        "id": "95c4b58937241783",
        "type": "http request",
        "z": "d4e33c145f0fb0dd",
        "name": "container data POST",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://rm.fsv.cvut.cz/upload_container_data",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1140,
        "y": 840,
        "wires": [
            []
        ]
    },
    {
        "id": "9b804076e0b2fcc3",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "msg.payload",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1110,
        "y": 880,
        "wires": []
    },
    {
        "id": "a20d9adb53729f1a",
        "type": "file",
        "z": "d4e33c145f0fb0dd",
        "name": "Write /home/images/my_image.jpg",
        "filename": "/home/images/my_image.jpg",
        "filenameType": "str",
        "appendNewline": false,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "binary",
        "x": 1720,
        "y": 1060,
        "wires": [
            [
                "49020dac68363494"
            ]
        ]
    },
    {
        "id": "b1f5645452b84351",
        "type": "inject",
        "z": "d4e33c145f0fb0dd",
        "name": "",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1450,
        "y": 1060,
        "wires": [
            [
                "a20d9adb53729f1a"
            ]
        ]
    },
    {
        "id": "49020dac68363494",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "debug 7",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1960,
        "y": 1060,
        "wires": []
    },
    {
        "id": "6764ce15769533e8",
        "type": "comment",
        "z": "d4e33c145f0fb0dd",
        "name": "TCP image from Nb-IoT module",
        "info": "",
        "x": 430,
        "y": 1020,
        "wires": []
    },
    {
        "id": "9183fe24361739b0",
        "type": "function",
        "z": "d4e33c145f0fb0dd",
        "name": "Return to InfluxDB",
        "func": "let incoming = msg.payload;\n\n// 1) Decode the hex \"data\" field into an 11-byte Buffer.\n//    - Byte 0: Battery percentage\n//    - Byte 1: GPS fix time in seconds\n//    - Byte 2: Wake-up reason (esp_sleep_get_wakeup_cause())\n//    - Bytes 3..6: Latitude (signed 32-bit, microdegrees)\n//    - Bytes 7..10: Longitude (signed 32-bit, microdegrees)\nlet dataHex = incoming.data;               // e.g. \"550102fc88b400db8fd1\" (example hex)\nlet bytes = Buffer.from(dataHex, \"hex\");   // Convert hex to Buffer\n\n// Battery (first byte)\nlet battery = bytes[0];  // e.g. 0x55 = 85 decimal\n\n// GPS fix time in seconds (second byte)\nlet gpsFixTime = bytes[1];\n\n// Wake-up reason (second byte)\nlet wakeUpReason = bytes[2];\nlet wakeUpReasonText = (() => {\n    switch (wakeUpReason) {\n        case 0: return \"Normal Reset\";\n        case 1: return \"All Wakeup Sources\";\n        case 2: return \"Shake Detection\";\n        case 3: return \"External Signal RTC\";\n        case 4: return \"Timer\";\n        case 5: return \"Touchpad\";\n        case 6: return \"ULP Program\";\n        case 7: return \"GPIO\";\n        case 8: return \"UART\";\n        case 9: return \"WIFI\";\n        case 10: return \"COCPU Int\";\n        case 11: return \"COCPU Crash\";\n        case 12: return \"Bluetooth\";\n        default: return \"Unknown\";\n    }\n})();\n\n// Latitude (signed 32-bit, big-endian at bytes[3..6])\nlet latInt = bytes.readInt32BE(3);\n// Longitude (signed 32-bit, big-endian at bytes[7..10])\nlet lonInt = bytes.readInt32BE(7);\n\n// Convert to float degrees\nlet latitude = latInt / 1_000_000;\nlet longitude = lonInt / 1_000_000;\n\n// 2) Count gateways\nlet gatewayCount = (incoming.gws || []).length;\n\n// 2a) Compute bestRSSI (max RSSI from the gateways)\nlet bestRSSI = (incoming.gws || []).reduce(\n    (acc, gw) => Math.max(acc, gw.rssi),\n    Number.NEGATIVE_INFINITY\n);\n\n// 3) Create an array of measurement objects for InfluxDB\n//    (One measurement for the device info)\nlet deviceMeasurement = {\n    measurement: \"device_data\",  // <-- rename as you like\n    tags: {\n        deviceEUI: incoming.EUI || \"unknown_device\"\n    },\n    fields: {\n        battery: battery,\n        gpsFixTime: gpsFixTime,  // Add GPS fix time in seconds\n        wakeUpReason: wakeUpReason,  // Keep the numeric value\n        wakeUpReasonText: wakeUpReasonText,  // Add the human-readable text\n        latitude: latitude,\n        longitude: longitude,\n        gatewayCount: gatewayCount,\n        bestRSSI: bestRSSI,\n        gates: gatewayCount\n    },\n    timestamp: new Date() // or use incoming.ts for server-provided timestamp\n};\n\n// Optionally, store each gateway's RSSI/SNR as separate points:\nlet gatewayMeasurements = (incoming.gws || []).map(gateway => ({\n    measurement: \"gateway_data\",  // <-- rename as you like\n    tags: {\n        deviceEUI: incoming.EUI || \"unknown_device\",\n        gatewayEUI: gateway.gweui\n    },\n    fields: {\n        rssi: gateway.rssi,\n        snr: gateway.snr\n    },\n    timestamp: new Date()\n}));\n\n// Combine into a single array\nmsg.payload = [deviceMeasurement, ...gatewayMeasurements];\n\n// Return to InfluxDB Out node\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 720,
        "wires": [
            [
                "8a0dc761b2fd6cbe",
                "301d811202473308"
            ]
        ]
    },
    {
        "id": "c188864675788140",
        "type": "function",
        "z": "d4e33c145f0fb0dd",
        "name": "Return to InfluxDB backup",
        "func": "let incoming = msg.payload;\n\n// 1) Decode the hex \"data\" field into a 10-byte Buffer.\n//    - Byte 0: Battery percentage\n//    - Byte 1: Wake-up reason (esp_sleep_get_wakeup_cause())\n//    - Bytes 2..5: Latitude (signed 32-bit, microdegrees)\n//    - Bytes 6..9: Longitude (signed 32-bit, microdegrees)\nlet dataHex = incoming.data;               // e.g. \"550102fc88b400db8fd1\" (example hex)\nlet bytes = Buffer.from(dataHex, \"hex\");   // Convert hex to Buffer\n\n// Battery (first byte)\nlet battery = bytes[0];  // e.g. 0x55 = 85 decimal\n\n// Wake-up reason (second byte)\nlet wakeUpReason = bytes[1]; \nlet wakeUpReasonText = (() => {\n    switch(wakeUpReason) {\n        case 0: return \"Normal Reset\";\n        case 1: return \"All Wakeup Sources\";\n        case 2: return \"Shake Detection\";\n        case 3: return \"External Signal RTC\";\n        case 4: return \"Timer\";\n        case 5: return \"Touchpad\";\n        case 6: return \"ULP Program\";\n        case 7: return \"GPIO\";\n        case 8: return \"UART\";\n        case 9: return \"WIFI\";\n        case 10: return \"COCPU Int\";\n        case 11: return \"COCPU Crash\";\n        case 12: return \"Bluetooth\";\n        default: return \"Unknown\";\n    }\n})();\n\n// Latitude (signed 32-bit, big-endian at bytes[2..5])\nlet latInt = bytes.readInt32BE(2);\n// Longitude (signed 32-bit, big-endian at bytes[6..9])\nlet lonInt = bytes.readInt32BE(6);\n\n// Convert to float degrees\nlet latitude = latInt / 1_000_000;\nlet longitude = lonInt / 1_000_000;\n\n// 2) Count gateways\nlet gatewayCount = (incoming.gws || []).length;\n\n// 2a) Compute bestRSSI (max RSSI from the gateways)\nlet bestRSSI = (incoming.gws || []).reduce(\n    (acc, gw) => Math.max(acc, gw.rssi),\n    Number.NEGATIVE_INFINITY\n);\n\n// 3) Create an array of measurement objects for InfluxDB\n//    (One measurement for the device info)\nlet deviceMeasurement = {\n    measurement: \"device_data\",  // <-- rename as you like\n    tags: {\n        deviceEUI: incoming.EUI || \"unknown_device\"\n    },\n    fields: {\n        battery: battery,\n        wakeUpReason: wakeUpReason,  // Keep the numeric value\n        wakeUpReasonText: wakeUpReasonText,  // Add the human-readable text\n        latitude: latitude,\n        longitude: longitude,\n        gatewayCount: gatewayCount,\n        bestRSSI: bestRSSI,\n        gates: gatewayCount\n    },\n    timestamp: new Date() // or use incoming.ts for server-provided timestamp\n};\n\n// Optionally, store each gateway's RSSI/SNR as separate points:\nlet gatewayMeasurements = (incoming.gws || []).map(gateway => ({\n    measurement: \"gateway_data\",  // <-- rename as you like\n    tags: {\n        deviceEUI: incoming.EUI || \"unknown_device\",\n        gatewayEUI: gateway.gweui\n    },\n    fields: {\n        rssi: gateway.rssi,\n        snr: gateway.snr\n    },\n    timestamp: new Date()\n}));\n\n// Combine into a single array\nmsg.payload = [deviceMeasurement, ...gatewayMeasurements];\n\n// Return to InfluxDB Out node\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "674d5681f3a17cb9",
        "type": "function",
        "z": "d4e33c145f0fb0dd",
        "name": "Return to rm.fsv.cvut.cz backup",
        "func": "// 1) Parse incoming JSON\nlet incoming = msg.payload;\n\nlet dataHex = incoming.data;\nlet bytes = Buffer.from(dataHex, \"hex\");\n\n// Safety check: ensure we have at least 9 bytes\nif (bytes.length < 9) {\n    node.warn(\"Not enough data bytes to decode (need 9).\");\n    return null;\n}\n\n// Battery (first byte)\nlet battery = bytes[0]; // e.g. 0x53 -> 83 decimal\n\n// Latitude (signed 32-bit, big-endian at bytes[1..4])\nlet latInt = bytes.readInt32BE(1);\n// Longitude (signed 32-bit, big-endian at bytes[5..8])\nlet lonInt = bytes.readInt32BE(5);\n\n// Convert microdegrees to float degrees\nlet latitude = latInt / 1_000_000;\nlet longitude = lonInt / 1_000_000;\n\n// 3) Construct final POST body\n// Feel free to rename fields or adjust them as needed\nlet postBody = {\n    temperature: 0,\n    humidity: 0,\n    distance: 0,\n    latitude: latitude,\n    longitude: longitude,\n    container_id: 4,      \n    image_status: 1,\n    battery_status: battery\n};\n\n// Assign to msg.payload for the next node (e.g., an HTTP Request node)\nmsg.payload = postBody;\n\n// Return message\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "8219c6e538162b47",
        "type": "function",
        "z": "d4e33c145f0fb0dd",
        "name": "Return UDP to rm.fsv.cvut.cz",
        "func": "// Parse incoming message\nlet incoming = msg.payload;\n\n// Convert Buffer to string\nlet dataStr;\nif (Buffer.isBuffer(incoming)) {\n    // Convert Buffer directly to string\n    dataStr = incoming.toString();\n    node.warn(\"Decoded string: \" + dataStr);\n} else {\n    node.error(\"Expected Buffer input\");\n    return null;\n}\n\ntry {\n    // Split measurement and fields\n    let parts = dataStr.split(' ');\n    if (parts.length !== 2) {\n        throw new Error(\"Invalid message format\");\n    }\n\n    // Parse fields\n    let values = {};\n    let fields = parts[1].split(',');\n    fields.forEach(field => {\n        let [key, value] = field.split('=');\n        values[key] = Number(value);\n    });\n\n    // Construct final POST body\n    let postBody = {\n        temperature: values.temperature,\n        humidity: values.humidity,\n        distance: 0,\n        latitude: values.latitude,\n        longitude: values.longitude,\n        container_id: 5,\n        image_status: 1,\n        battery_status: values.battery,\n        gps_fix_time: 0,\n        wake_up_reason: 0\n    };\n\n    msg.payload = postBody;\n    return msg;\n\n} catch (error) {\n    node.error(\"Failed to parse message: \" + error.message);\n    node.error(\"Raw data: \" + dataStr);\n    return null;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 1260,
        "wires": [
            [
                "4b50ec84a53eb45e",
                "75764320fe09463f"
            ]
        ]
    },
    {
        "id": "4b50ec84a53eb45e",
        "type": "http request",
        "z": "d4e33c145f0fb0dd",
        "name": "container data POST",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://rm.fsv.cvut.cz/upload_container_data",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1140,
        "y": 1260,
        "wires": [
            []
        ]
    },
    {
        "id": "676072cdc8d5c271",
        "type": "comment",
        "z": "d4e33c145f0fb0dd",
        "name": "UDP downlink message to the Nb-IoT module",
        "info": "",
        "x": 410,
        "y": 1480,
        "wires": []
    },
    {
        "id": "070c81cd79d49dea",
        "type": "inject",
        "z": "d4e33c145f0fb0dd",
        "name": "Test Downlink",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "48656C6C6F",
        "payloadType": "str",
        "x": 510,
        "y": 1540,
        "wires": [
            [
                "91bea4dac31c0717"
            ]
        ]
    },
    {
        "id": "2b8fdb571a2ed536",
        "type": "udp out",
        "z": "d4e33c145f0fb0dd",
        "name": "BC95 Downlink",
        "addr": "100.121.61.85",
        "iface": "",
        "port": "3014",
        "ipv": "udp4",
        "outport": "3014",
        "base64": false,
        "multicast": "false",
        "x": 980,
        "y": 1540,
        "wires": []
    },
    {
        "id": "91bea4dac31c0717",
        "type": "function",
        "z": "d4e33c145f0fb0dd",
        "name": "Format Downlink",
        "func": "// Convert string to hex\nfunction stringToHex(str) {\n    return Buffer.from(str).toString('hex').toUpperCase();\n}\n\n// Your message\nconst message = 'Hello';\n\n// Add debug output\nnode.warn('Sending message: ' + message);\nnode.warn('As hex: ' + stringToHex(message));\n\n// Convert to hex\nmsg.payload = stringToHex(message);\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 1540,
        "wires": [
            [
                "2b8fdb571a2ed536"
            ]
        ]
    },
    {
        "id": "your_inject_node_id",
        "type": "inject",
        "z": "d4e33c145f0fb0dd",
        "name": "Trigger UDP Send",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "Hello from Node-RED!",
        "payloadType": "str",
        "x": 1150,
        "y": 1400,
        "wires": [
            [
                "your_udp_out_node_id",
                "7a94393c06714a97"
            ]
        ]
    },
    {
        "id": "your_udp_out_node_id",
        "type": "udp out",
        "z": "d4e33c145f0fb0dd",
        "name": "Send to ESP32 UDP",
        "addr": "100.121.61.85",
        "iface": "",
        "port": "0",
        "outport": "",
        "base64": false,
        "multicast": "false",
        "x": 1400,
        "y": 1400,
        "wires": []
    },
    {
        "id": "7a94393c06714a97",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "UDP debug",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1370,
        "y": 1460,
        "wires": []
    },
    {
        "id": "d5830a1236a54712",
        "type": "udp in",
        "z": "d4e33c145f0fb0dd",
        "name": "UDP in message downlink maybe",
        "iface": "",
        "port": "8012",
        "ipv": "udp4",
        "multicast": "false",
        "group": "",
        "datatype": "buffer",
        "x": 450,
        "y": 1380,
        "wires": [
            [
                "0e00bf39ef742b37"
            ]
        ]
    },
    {
        "id": "0e00bf39ef742b37",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "UDP debug",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 730,
        "y": 1380,
        "wires": []
    },
    {
        "id": "75764320fe09463f",
        "type": "debug",
        "z": "d4e33c145f0fb0dd",
        "name": "msg.payload",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1110,
        "y": 1300,
        "wires": []
    },
    {
        "id": "56b7c51ca754bd0b",
        "type": "inject",
        "z": "d4e33c145f0fb0dd",
        "name": "JSON test data",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"cmd\":\"gw\",\"ts\":1736855162722,\"data\":\"531E0102EB2DAC00DCF82C\",\"fcnt\":0,\"port\":1,\"freq\":868500000,\"dr\":\"SF7 BW125 4/5\",\"ack\":false,\"gws\":[{\"rssi\":-84,\"snr\":10.5,\"gweui\":\"647FDAFFFF007577\",\"ant\":0},{\"rssi\":-94,\"snr\":6.25,\"gweui\":\"647FDAFFFF0069CB\",\"ant\":0},{\"rssi\":-120,\"snr\":-10,\"gweui\":\"647FDAFFFF00AD6F\",\"ant\":0},{\"rssi\":-110,\"snr\":-3,\"gweui\":\"647FDAFFFF006A47\",\"ant\":0}],\"bat\":255,\"EUI\":\"70B3D57ED800386A\"}",
        "payloadType": "json",
        "x": 480,
        "y": 680,
        "wires": [
            [
                "9183fe24361739b0"
            ]
        ]
    },
    {
        "id": "da93bc8d835d541e",
        "type": "mqtt-broker",
        "name": "CRA MQTT",
        "broker": "ssl://mqtt.iot.cra.cz",
        "port": "8883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "9740419a576efa0b",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "influxDB google VM localhost",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://localhost:8086",
        "timeout": 10,
        "rejectUnauthorized": true
    }
]